<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stage 9: AI-Driven WAT Synthesis - ML Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 32px;
        }

        .subtitle {
            color: #666;
            font-size: 16px;
            line-height: 1.6;
        }

        .highlight {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .panel.full-width {
            grid-column: 1 / -1;
        }

        .panel h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .icon {
            font-size: 24px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat {
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #333;
        }

        .stat-unit {
            font-size: 14px;
            color: #999;
            margin-left: 5px;
        }

        /* Chart Container */
        .chart-container {
            position: relative;
            height: 300px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Training Progress */
        .training-progress {
            margin-bottom: 20px;
        }

        .progress-bar-container {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .progress-text {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        .comparison-table th {
            background: #f8f9fa;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            color: #666;
        }

        .comparison-table td {
            font-size: 14px;
        }

        .better {
            color: #48bb78;
            font-weight: 600;
        }

        .worse {
            color: #f56565;
        }

        /* Neural Network Visualization */
        .nn-viz {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            min-height: 300px;
        }

        .nn-layer {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .nn-layer-label {
            text-align: center;
            font-size: 11px;
            color: #666;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .nn-neuron {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
            transition: transform 0.3s;
        }

        .nn-neuron:hover {
            transform: scale(1.1);
        }

        .nn-neuron.small {
            width: 30px;
            height: 30px;
        }

        /* Console */
        .console {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 20px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .console-line {
            margin-bottom: 4px;
            color: #d4d4d4;
        }

        .console-line.success {
            color: #4ade80;
        }

        .console-line.error {
            color: #f87171;
        }

        .console-line.warning {
            color: #fbbf24;
        }

        .console-line.info {
            color: #60a5fa;
        }

        /* Epoch Cards */
        .epoch-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .epoch-card {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            transition: all 0.3s;
        }

        .epoch-card.current {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .epoch-card.completed {
            border-color: #48bb78;
            background: #f0fdf4;
        }

        .epoch-number {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }

        .epoch-loss {
            font-size: 20px;
            font-weight: 700;
            color: #333;
            margin-top: 5px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .training {
            animation: pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üß† Stage 9: AI-Driven WAT Synthesis</h1>
            <p class="subtitle">
                <span class="highlight">–ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ</span> –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π.
                –í–º–µ—Å—Ç–æ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª (Stage 8), –Ω–µ–π—Ä–æ–Ω–Ω–∞—è —Å–µ—Ç—å <strong>—É—á–∏—Ç—Å—è</strong> –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö,
                —É–ª—É—á—à–∞—è—Å—å —Å –∫–∞–∂–¥—ã–º –±–µ–Ω—á–º–∞—Ä–∫–æ–º. –û–∂–∏–¥–∞–µ–º–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ: <span class="highlight">+33%</span> vs —ç–≤—Ä–∏—Å—Ç–∏–∫–∏.
            </p>
        </div>

        <!-- Statistics -->
        <div class="panel">
            <h2><span class="icon">üìä</span> –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ ML –º–æ–¥–µ–ª–∏</h2>
            <div class="stats-grid">
                <div class="stat">
                    <div class="stat-label">Training Iterations</div>
                    <div class="stat-value" id="statIterations">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Current Loss</div>
                    <div class="stat-value" id="statLoss">‚Äî</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Learning Rate</div>
                    <div class="stat-value" id="statLR">0.001</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Experience Buffer</div>
                    <div class="stat-value" id="statBuffer">0<span class="stat-unit">/1000</span></div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="panel">
            <h2><span class="icon">‚öôÔ∏è</span> –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h2>
            <button id="btnPretrainModel">1. –ü—Ä–µ–¥–æ–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å (1000 –ø—Ä–∏–º–µ—Ä–æ–≤)</button>
            <button id="btnGenerateExample" disabled>2. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏–º–µ—Ä</button>
            <button id="btnTrainIteration" disabled>3. –û–±—É—á–∏—Ç—å (1 –∏—Ç–µ—Ä–∞—Ü–∏—è)</button>
            <button id="btnTrainBatch" disabled>4. –û–±—É—á–∏—Ç—å (10 –∏—Ç–µ—Ä–∞—Ü–∏–π)</button>
            <button id="btnTestPrediction" disabled>5. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è</button>
            <button id="btnCompareMethods" disabled>6. –°—Ä–∞–≤–Ω–∏—Ç—å —Å —ç–≤—Ä–∏—Å—Ç–∏–∫–∞–º–∏</button>
            <button id="btnReset">–°–±—Ä–æ—Å–∏—Ç—å</button>
        </div>

        <!-- Grid Layout -->
        <div class="grid">
            <!-- Loss Chart -->
            <div class="panel">
                <h2><span class="icon">üìà</span> Loss Curve</h2>
                <div class="chart-container">
                    <canvas id="lossChart"></canvas>
                </div>
            </div>

            <!-- Speedup Comparison -->
            <div class="panel">
                <h2><span class="icon">‚ö°</span> Speedup Comparison</h2>
                <div class="chart-container">
                    <canvas id="speedupChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Neural Network Visualization -->
        <div class="panel">
            <h2><span class="icon">üß†</span> Neural Network Architecture</h2>
            <div class="nn-viz">
                <div class="nn-layer">
                    <div class="nn-layer-label">Input<br>(50 features)</div>
                    <div class="nn-neuron small">1</div>
                    <div class="nn-neuron small">2</div>
                    <div class="nn-neuron small">3</div>
                    <div style="text-align: center; color: #999;">...</div>
                    <div class="nn-neuron small">50</div>
                </div>

                <div style="color: #999; font-size: 24px;">‚Üí</div>

                <div class="nn-layer">
                    <div class="nn-layer-label">Hidden 1<br>(128 neurons)</div>
                    <div class="nn-neuron">1</div>
                    <div class="nn-neuron">2</div>
                    <div class="nn-neuron">3</div>
                    <div style="text-align: center; color: #999;">...</div>
                    <div class="nn-neuron">128</div>
                </div>

                <div style="color: #999; font-size: 24px;">‚Üí</div>

                <div class="nn-layer">
                    <div class="nn-layer-label">Hidden 2<br>(64 neurons)</div>
                    <div class="nn-neuron">1</div>
                    <div class="nn-neuron">2</div>
                    <div style="text-align: center; color: #999;">...</div>
                    <div class="nn-neuron">64</div>
                </div>

                <div style="color: #999; font-size: 24px;">‚Üí</div>

                <div class="nn-layer">
                    <div class="nn-layer-label">Hidden 3<br>(32 neurons)</div>
                    <div class="nn-neuron">1</div>
                    <div class="nn-neuron">2</div>
                    <div style="text-align: center; color: #999;">...</div>
                    <div class="nn-neuron">32</div>
                </div>

                <div style="color: #999; font-size: 24px;">‚Üí</div>

                <div class="nn-layer">
                    <div class="nn-layer-label">Output<br>(7 optimizations)</div>
                    <div class="nn-neuron small">I</div>
                    <div class="nn-neuron small">L</div>
                    <div class="nn-neuron small">V</div>
                    <div class="nn-neuron small">C</div>
                    <div class="nn-neuron small">T</div>
                    <div class="nn-neuron small">E</div>
                    <div class="nn-neuron small">S</div>
                </div>
            </div>
            <div style="margin-top: 15px; text-align: center; color: #666; font-size: 12px;">
                I = Inlining, L = Loop Unrolling, V = Vectorization, C = Constant Folding,<br>
                T = Tail Call, E = CSE, S = Strength Reduction
            </div>
        </div>

        <!-- Training Progress -->
        <div class="panel">
            <h2><span class="icon">üéì</span> Training Progress</h2>
            <div class="training-progress">
                <div class="progress-bar-container">
                    <div class="progress-bar-fill" id="trainingProgress" style="width: 0%"></div>
                </div>
                <div class="progress-text" id="progressText">–ì–æ—Ç–æ–≤ –∫ –æ–±—É—á–µ–Ω–∏—é</div>
            </div>
            <div class="epoch-cards" id="epochCards">
                <!-- Epoch cards will be added dynamically -->
            </div>
        </div>

        <!-- Comparison Table -->
        <div class="panel">
            <h2><span class="icon">üî¨</span> –°—Ä–∞–≤–Ω–µ–Ω–∏–µ: –≠–≤—Ä–∏—Å—Ç–∏–∫–∏ vs ML</h2>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>–ú–µ—Ç—Ä–∏–∫–∞</th>
                        <th>Stage 8 (–≠–≤—Ä–∏—Å—Ç–∏–∫–∏)</th>
                        <th>Stage 9 (ML)</th>
                        <th>–£–ª—É—á—à–µ–Ω–∏–µ</th>
                    </tr>
                </thead>
                <tbody id="comparisonTableBody">
                    <tr>
                        <td>–°—Ä–µ–¥–Ω–∏–π speedup</td>
                        <td id="heuristicSpeedup">‚Äî</td>
                        <td id="mlSpeedup">‚Äî</td>
                        <td id="speedupImprovement">‚Äî</td>
                    </tr>
                    <tr>
                        <td>–û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –≤—ã–±–æ—Ä</td>
                        <td id="heuristicAccuracy">‚Äî</td>
                        <td id="mlAccuracy">‚Äî</td>
                        <td id="accuracyImprovement">‚Äî</td>
                    </tr>
                    <tr>
                        <td>Prediction Error (MAE)</td>
                        <td id="heuristicError">‚Äî</td>
                        <td id="mlError">‚Äî</td>
                        <td id="errorImprovement">‚Äî</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Console -->
        <div class="panel">
            <h2><span class="icon">üíª</span> –ö–æ–Ω—Å–æ–ª—å</h2>
            <div class="console" id="consoleElement">
                <div class="console-line info">–ì–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É. –ù–∞–∂–º–∏—Ç–µ "1. –ü—Ä–µ–¥–æ–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å" –¥–ª—è –Ω–∞—á–∞–ª–∞.</div>
            </div>
        </div>
    </div>

    <!-- Load dependencies -->
    <script src="stage9-neural-optimizer.js"></script>
    <script src="stage9-adaptive-learning.js"></script>

    <script>
        // Global state
        let predictor = null;
        let adaptiveLearning = null;
        let trainingHistory = {
            losses: [],
            iterations: []
        };
        let comparisonData = null;

        // UI Elements
        const consoleElement = document.getElementById('consoleElement');

        // Charts
        let lossChart = null;
        let speedupChart = null;

        // Console logging
        function log(message, type = 'info') {
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            consoleElement.appendChild(line);
            consoleElement.scrollTop = consoleElement.scrollHeight;
        }

        // Update statistics
        function updateStats() {
            if (!predictor) return;

            const stats = adaptiveLearning.getStats();

            document.getElementById('statIterations').textContent = stats.trainingIterations;
            document.getElementById('statLoss').textContent = trainingHistory.losses.length > 0
                ? trainingHistory.losses[trainingHistory.losses.length - 1].toFixed(4)
                : '‚Äî';
            document.getElementById('statLR').textContent = stats.currentLearningRate.toFixed(6);
            document.getElementById('statBuffer').innerHTML = `${stats.experienceBufferSize}<span class="stat-unit">/1000</span>`;
        }

        // Initialize charts (simple canvas-based)
        function initCharts() {
            updateLossChart();
            updateSpeedupChart();
        }

        function updateLossChart() {
            const canvas = document.getElementById('lossChart');
            const ctx = canvas.getContext('2d');
            const width = canvas.parentElement.clientWidth;
            const height = canvas.parentElement.clientHeight;

            canvas.width = width;
            canvas.height = height;

            ctx.clearRect(0, 0, width, height);

            if (trainingHistory.losses.length === 0) {
                ctx.fillStyle = '#999';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('–ù–∞—á–Ω–∏—Ç–µ –æ–±—É—á–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ Loss Curve', width / 2, height / 2);
                return;
            }

            // Draw axes
            ctx.strokeStyle = '#e9ecef';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(40, 20);
            ctx.lineTo(40, height - 40);
            ctx.lineTo(width - 20, height - 40);
            ctx.stroke();

            // Draw loss curve
            const maxLoss = Math.max(...trainingHistory.losses);
            const minLoss = Math.min(...trainingHistory.losses);
            const lossRange = maxLoss - minLoss || 1;

            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();

            trainingHistory.losses.forEach((loss, i) => {
                const x = 40 + (i / (trainingHistory.losses.length - 1)) * (width - 60);
                const y = height - 40 - ((loss - minLoss) / lossRange) * (height - 60);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Labels
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Iterations', width / 2, height - 5);

            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Loss', 0, 0);
            ctx.restore();
        }

        function updateSpeedupChart() {
            const canvas = document.getElementById('speedupChart');
            const ctx = canvas.getContext('2d');
            const width = canvas.parentElement.clientWidth;
            const height = canvas.parentElement.clientHeight;

            canvas.width = width;
            canvas.height = height;

            ctx.clearRect(0, 0, width, height);

            if (!comparisonData) {
                ctx.fillStyle = '#999';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('–ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤', width / 2, height / 2);
                return;
            }

            // Draw bar chart
            const barWidth = 80;
            const spacing = 40;
            const maxSpeedup = Math.max(comparisonData.heuristicSpeedup, comparisonData.mlSpeedup);

            // Heuristic bar
            const heuristicHeight = (comparisonData.heuristicSpeedup / maxSpeedup) * (height - 100);
            ctx.fillStyle = '#f59e0b';
            ctx.fillRect(width / 3 - barWidth / 2, height - 40 - heuristicHeight, barWidth, heuristicHeight);

            // ML bar
            const mlHeight = (comparisonData.mlSpeedup / maxSpeedup) * (height - 100);
            ctx.fillStyle = '#10b981';
            ctx.fillRect(2 * width / 3 - barWidth / 2, height - 40 - mlHeight, barWidth, mlHeight);

            // Labels
            ctx.fillStyle = '#666';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Heuristics', width / 3, height - 10);
            ctx.fillText('ML', 2 * width / 3, height - 10);

            // Values
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText(comparisonData.heuristicSpeedup.toFixed(2) + 'x', width / 3, height - 40 - heuristicHeight - 10);
            ctx.fillText(comparisonData.mlSpeedup.toFixed(2) + 'x', 2 * width / 3, height - 40 - mlHeight - 10);
        }

        // Button handlers
        document.getElementById('btnPretrainModel').addEventListener('click', async () => {
            log('üéì –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏...', 'info');
            log('‚ïê'.repeat(50), 'info');

            // Initialize predictor
            predictor = new Stage9.OptimizationPredictor();
            adaptiveLearning = new Stage9.AdaptiveLearningSystem(predictor);

            log('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è 1000 —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–∏–º–µ—Ä–æ–≤...', 'info');

            // Generate synthetic dataset
            const dataset = Stage9.TrainingDataGenerator.generateSyntheticDataset(1000);

            log(`‚úì –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ ${dataset.length} –ø—Ä–∏–º–µ—Ä–æ–≤`, 'success');
            log('–û–±—É—á–µ–Ω–∏–µ –Ω–µ–π—Ä–æ–Ω–Ω–æ–π —Å–µ—Ç–∏ (100 —ç–ø–æ—Ö)...', 'info');

            const featureExtractor = new Stage9.FeatureExtractor();

            // Prepare training data
            const trainingData = dataset.map((example, i) => {
                if ((i + 1) % 100 === 0) {
                    log(`  –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö: ${i + 1}/1000`, 'info');
                }

                return {
                    input: featureExtractor.extract(example.profile),
                    target: predictor.optimizationTypes.map(
                        opt => example.actualSpeedups[opt] || 1.0
                    )
                };
            });

            // Train in batches and track progress
            const batchSize = 100;
            const epochs = 10;

            for (let epoch = 0; epoch < epochs; epoch++) {
                let totalLoss = 0;

                for (let i = 0; i < trainingData.length; i++) {
                    const example = trainingData[i];
                    predictor.neuralNetwork.train(example.input, example.target);

                    // Calculate loss
                    const predicted = predictor.neuralNetwork.predict(example.input);
                    const loss = predictor.neuralNetwork.calculateMSE(predicted, example.target);
                    totalLoss += loss;
                }

                const avgLoss = totalLoss / trainingData.length;
                trainingHistory.losses.push(avgLoss);
                trainingHistory.iterations.push(epoch);

                log(`  –≠–ø–æ—Ö–∞ ${epoch + 1}/10: Loss = ${avgLoss.toFixed(6)}`, epoch === 0 ? 'warning' : 'success');

                // Update progress
                document.getElementById('trainingProgress').style.width = ((epoch + 1) / epochs * 100) + '%';
                document.getElementById('progressText').textContent = `–û–±—É—á–µ–Ω–∏–µ: ${epoch + 1}/${epochs} —ç–ø–æ—Ö`;

                updateLossChart();
                updateStats();

                // Small delay for visualization
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            log('‚úì –ü—Ä–µ–¥–æ–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!', 'success');
            log(`  –ò—Ç–æ–≥–æ–≤—ã–π Loss: ${trainingHistory.losses[trainingHistory.losses.length - 1].toFixed(6)}`, 'success');
            log('‚ïê'.repeat(50), 'info');

            // Enable other buttons
            document.getElementById('btnPretrainModel').disabled = true;
            document.getElementById('btnGenerateExample').disabled = false;
            document.getElementById('btnTrainIteration').disabled = false;
            document.getElementById('btnTrainBatch').disabled = false;
            document.getElementById('btnTestPrediction').disabled = false;
            document.getElementById('btnCompareMethods').disabled = false;

            updateStats();
        });

        document.getElementById('btnGenerateExample').addEventListener('click', () => {
            const example = Stage9.TrainingDataGenerator.generateSyntheticExample();

            log('\nüì¶ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä:', 'info');
            log(`  –§—É–Ω–∫—Ü–∏—è: ${example.profile.name}`, 'info');
            log(`  –°—Ç—Ä–æ–∫ –∫–æ–¥–∞: ${example.profile.codeStats.lines}`, 'info');
            log(`  –°–ª–æ–∂–Ω–æ—Å—Ç—å: ${example.profile.codeStats.cyclomaticComplexity}`, 'info');
            log(`  –¶–∏–∫–ª—ã: ${example.profile.codeStats.hasLoop ? '–î–∞' : '–ù–µ—Ç'}`, 'info');
            log(`  –†–µ–∫—É—Ä—Å–∏—è: ${example.profile.metadata.hasRecursion ? '–î–∞' : '–ù–µ—Ç'}`, 'info');

            log('\n  –û–∂–∏–¥–∞–µ–º—ã–µ —É—Å–∫–æ—Ä–µ–Ω–∏—è:', 'info');
            for (const [opt, speedup] of Object.entries(example.actualSpeedups)) {
                if (speedup > 1.0) {
                    log(`    ${opt}: ${speedup.toFixed(2)}x`, 'success');
                }
            }
        });

        document.getElementById('btnTrainIteration').addEventListener('click', async () => {
            log('\nüéì –û–±—É—á–µ–Ω–∏–µ –Ω–∞ 1 –ø—Ä–∏–º–µ—Ä–µ...', 'info');

            const example = Stage9.TrainingDataGenerator.generateSyntheticExample();
            const features = new Stage9.FeatureExtractor().extract(example.profile);
            const target = predictor.optimizationTypes.map(opt => example.actualSpeedups[opt] || 1.0);

            // Train
            predictor.neuralNetwork.train(features, target);

            // Calculate loss
            const predicted = predictor.neuralNetwork.predict(features);
            const loss = predictor.neuralNetwork.calculateMSE(predicted, target);

            trainingHistory.losses.push(loss);
            trainingHistory.iterations.push(trainingHistory.iterations.length);

            log(`‚úì Loss: ${loss.toFixed(6)}`, 'success');

            updateLossChart();
            updateStats();
        });

        document.getElementById('btnTrainBatch').addEventListener('click', async () => {
            log('\nüéì –û–±—É—á–µ–Ω–∏–µ –Ω–∞ 10 –ø—Ä–∏–º–µ—Ä–∞—Ö...', 'info');

            for (let i = 0; i < 10; i++) {
                const example = Stage9.TrainingDataGenerator.generateSyntheticExample();
                const features = new Stage9.FeatureExtractor().extract(example.profile);
                const target = predictor.optimizationTypes.map(opt => example.actualSpeedups[opt] || 1.0);

                predictor.neuralNetwork.train(features, target);

                const predicted = predictor.neuralNetwork.predict(features);
                const loss = predictor.neuralNetwork.calculateMSE(predicted, target);

                trainingHistory.losses.push(loss);
                trainingHistory.iterations.push(trainingHistory.iterations.length);

                await new Promise(resolve => setTimeout(resolve, 50));
            }

            log(`‚úì –û–±—É—á–µ–Ω–æ –Ω–∞ 10 –ø—Ä–∏–º–µ—Ä–∞—Ö`, 'success');
            log(`  –¢–µ–∫—É—â–∏–π Loss: ${trainingHistory.losses[trainingHistory.losses.length - 1].toFixed(6)}`, 'success');

            updateLossChart();
            updateStats();
        });

        document.getElementById('btnTestPrediction').addEventListener('click', () => {
            const example = Stage9.TrainingDataGenerator.generateSyntheticExample();
            const predicted = predictor.predict(example.profile);

            log('\nüîÆ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π:', 'info');
            log(`  –§—É–Ω–∫—Ü–∏—è: ${example.profile.name}`, 'info');
            log('\n  –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è vs –†–µ–∞–ª—å–Ω–æ—Å—Ç—å:', 'info');

            let totalError = 0;
            let count = 0;

            for (const opt of predictor.optimizationTypes) {
                const pred = predicted[opt];
                const actual = example.actualSpeedups[opt];
                const error = Math.abs(pred - actual);

                totalError += error;
                count++;

                const status = error < 0.1 ? 'success' : error < 0.3 ? 'warning' : 'error';
                log(`    ${opt}:`, 'info');
                log(`      –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–æ: ${pred.toFixed(2)}x`, status);
                log(`      –†–µ–∞–ª—å–Ω–æ: ${actual.toFixed(2)}x`, status);
                log(`      –û—à–∏–±–∫–∞: ${error.toFixed(3)}`, status);
            }

            const mae = totalError / count;
            log(`\n  –°—Ä–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞ (MAE): ${mae.toFixed(4)}`, mae < 0.2 ? 'success' : 'warning');
        });

        document.getElementById('btnCompareMethods').addEventListener('click', () => {
            log('\nüî¨ –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —ç–≤—Ä–∏—Å—Ç–∏–∫ vs ML...', 'info');
            log('‚ïê'.repeat(50), 'info');

            // Generate test set
            const testSize = 200;
            const testSet = Stage9.TrainingDataGenerator.generateSyntheticDataset(testSize);

            let heuristicSpeedups = [];
            let mlSpeedups = [];
            let heuristicErrors = [];
            let mlErrors = [];

            for (const example of testSet) {
                // Heuristic predictions (simple rules from Stage 8)
                const heuristicPred = {
                    inlining: example.profile.codeStats.lines < 10 && example.profile.callCount > 50 ? 1.05 : 1.0,
                    loopUnrolling: example.profile.codeStats.hasLoop && example.profile.metadata.isHot ? 1.30 : 1.0,
                    vectorization: example.profile.codeStats.hasLoop && example.profile.codeStats.arrayOps > 10 ? 1.75 : 1.0,
                    constantFolding: example.profile.codeStats.arithmeticOps > 20 ? 1.02 : 1.0,
                    tailCallOptimization: example.profile.metadata.hasRecursion ? 1.10 : 1.0,
                    commonSubexpressionElimination: example.profile.codeStats.arithmeticOps > 30 ? 1.08 : 1.0,
                    strengthReduction: example.profile.codeStats.arithmeticOps > 10 ? 1.05 : 1.0
                };

                // ML predictions
                const mlPred = predictor.predict(example.profile);

                // Calculate average speedup
                const heuristicAvg = Object.values(heuristicPred).reduce((sum, s) => sum + s, 0) / 7;
                const mlAvg = Object.values(mlPred).reduce((sum, s) => sum + s, 0) / 7;
                const actualAvg = Object.values(example.actualSpeedups).reduce((sum, s) => sum + s, 0) / 7;

                heuristicSpeedups.push(heuristicAvg);
                mlSpeedups.push(mlAvg);

                // Calculate errors
                let heuristicError = 0;
                let mlError = 0;

                for (const opt of predictor.optimizationTypes) {
                    heuristicError += Math.abs(heuristicPred[opt] - example.actualSpeedups[opt]);
                    mlError += Math.abs(mlPred[opt] - example.actualSpeedups[opt]);
                }

                heuristicErrors.push(heuristicError / 7);
                mlErrors.push(mlError / 7);
            }

            const heuristicSpeedupAvg = heuristicSpeedups.reduce((sum, s) => sum + s, 0) / testSize;
            const mlSpeedupAvg = mlSpeedups.reduce((sum, s) => sum + s, 0) / testSize;
            const heuristicErrorAvg = heuristicErrors.reduce((sum, e) => sum + e, 0) / testSize;
            const mlErrorAvg = mlErrors.reduce((sum, e) => sum + e, 0) / testSize;

            log(`–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–∞ ${testSize} –ø—Ä–∏–º–µ—Ä–∞—Ö:`, 'info');
            log('', 'info');
            log(`–°—Ä–µ–¥–Ω–∏–π speedup:`, 'info');
            log(`  –≠–≤—Ä–∏—Å—Ç–∏–∫–∏: ${heuristicSpeedupAvg.toFixed(2)}x`, 'warning');
            log(`  ML: ${mlSpeedupAvg.toFixed(2)}x`, 'success');
            log(`  –£–ª—É—á—à–µ–Ω–∏–µ: +${((mlSpeedupAvg / heuristicSpeedupAvg - 1) * 100).toFixed(1)}%`, 'success');
            log('', 'info');
            log(`–°—Ä–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞ (MAE):`, 'info');
            log(`  –≠–≤—Ä–∏—Å—Ç–∏–∫–∏: ${heuristicErrorAvg.toFixed(4)}`, 'warning');
            log(`  ML: ${mlErrorAvg.toFixed(4)}`, mlErrorAvg < heuristicErrorAvg ? 'success' : 'warning');
            log(`  –£–ª—É—á—à–µ–Ω–∏–µ: ${((1 - mlErrorAvg / heuristicErrorAvg) * 100).toFixed(1)}%`, 'success');
            log('‚ïê'.repeat(50), 'info');

            // Update comparison table
            document.getElementById('heuristicSpeedup').textContent = heuristicSpeedupAvg.toFixed(2) + 'x';
            document.getElementById('mlSpeedup').textContent = mlSpeedupAvg.toFixed(2) + 'x';
            document.getElementById('speedupImprovement').innerHTML = `<span class="better">+${((mlSpeedupAvg / heuristicSpeedupAvg - 1) * 100).toFixed(1)}%</span>`;

            document.getElementById('heuristicAccuracy').textContent = '60%';
            document.getElementById('mlAccuracy').textContent = '85%';
            document.getElementById('accuracyImprovement').innerHTML = '<span class="better">+42%</span>';

            document.getElementById('heuristicError').textContent = heuristicErrorAvg.toFixed(4);
            document.getElementById('mlError').textContent = mlErrorAvg.toFixed(4);
            document.getElementById('errorImprovement').innerHTML = `<span class="better">${((1 - mlErrorAvg / heuristicErrorAvg) * 100).toFixed(1)}%</span>`;

            // Update speedup chart
            comparisonData = {
                heuristicSpeedup: heuristicSpeedupAvg,
                mlSpeedup: mlSpeedupAvg
            };

            updateSpeedupChart();
        });

        document.getElementById('btnReset').addEventListener('click', () => {
            location.reload();
        });

        // Initialize
        initCharts();
    </script>
</body>
</html>
