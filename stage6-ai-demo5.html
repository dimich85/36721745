<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered JavaScript Compiler - Stage 6 Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .content {
            padding: 40px;
        }
        
        .section {
            margin-bottom: 40px;
        }
        
        .section-title {
            font-size: 1.8em;
            color: #667eea;
            margin-bottom: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
        
        .success {
            color: #10b981;
            font-weight: 600;
        }
        
        .error {
            color: #ef4444;
            font-weight: 600;
        }
        
        .info {
            color: #667eea;
            font-weight: 600;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 15px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading {
            animation: pulse 1.5s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ AI-Powered JavaScript Compiler</h1>
            <p>–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∫–æ–¥–∞ —Å –º–∞—à–∏–Ω–Ω—ã–º –æ–±—É—á–µ–Ω–∏–µ–º</p>
        </div>
        
        <div class="content">
            <!-- –≠—Ç–∞–ø 1: –û–±—É—á–µ–Ω–∏–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ -->
            <div class="section">
                <div class="section-title">
                    üß† –≠—Ç–∞–ø 1: –û–±—É—á–µ–Ω–∏–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏
                </div>
                <div class="card">
                    <p style="margin-bottom: 15px;">
                        –ù–µ–π—Ä–æ—Å–µ—Ç—å —É—á–∏—Ç—Å—è –ø—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–æ–¥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫.
                        –ú—ã –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º 500 –ø—Ä–∏–º–µ—Ä–æ–≤ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –∏ –æ–±—É—á–∞–µ–º —Å–µ—Ç—å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω—ã –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.
                        –ë–æ–ª—å—à–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ø–æ—Ö –¥–∞—ë—Ç –±–æ–ª–µ–µ —Ç–æ—á–Ω—ã–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è, –Ω–æ —Ç—Ä–µ–±—É–µ—Ç –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏.
                    </p>
                    <button class="btn" onclick="trainNetwork(300)">üöÄ –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ (300 —ç–ø–æ—Ö)</button>
                    <button class="btn" onclick="trainNetwork(600)">üöÄ –ì–ª—É–±–æ–∫–æ–µ –æ–±—É—á–µ–Ω–∏–µ (600 —ç–ø–æ—Ö)</button>
                    <button class="btn" onclick="trainNetwork(1200)">üöÄ –≠–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ (1200 —ç–ø–æ—Ö)</button>
                    <div id="training-progress" class="progress-bar" style="display: none; margin-top: 20px;">
                        <div id="training-progress-fill" class="progress-fill">0%</div>
                    </div>
                    <div id="training-output" class="output" style="display: none;"></div>
                    <div id="training-stats" class="stats" style="display: none;"></div>
                </div>
            </div>
            
            <!-- –≠—Ç–∞–ø 2: –ê–Ω–∞–ª–∏–∑ –∫–æ–¥–∞ -->
            <div class="section">
                <div class="section-title">
                    üî¨ –≠—Ç–∞–ø 2: –ê–Ω–∞–ª–∏–∑ –∫–æ–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                </div>
                <div class="card">
                    <p style="margin-bottom: 15px;">
                        –í–≤–µ–¥–∏—Ç–µ JavaScript –∫–æ–¥ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞. –°–∏—Å—Ç–µ–º–∞ –∏–∑–≤–ª–µ—á—ë—Ç —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∏ –ø—Ä–µ–¥—Å–∫–∞–∂–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å.
                    </p>
                    <textarea id="user-code" placeholder="–í–≤–µ–¥–∏—Ç–µ JavaScript –∫–æ–¥ –∑–¥–µ—Å—å...">function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

function testFib() {
    var result = 0;
    for (var i = 0; i < 10; i++) {
        result += fibonacci(i);
    }
    return result;
}</textarea>
                    <br><br>
                    <button class="btn btn-secondary" onclick="analyzeCode()">üî¨ –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥</button>
                    <button class="btn btn-success" onclick="generateRandomCode()">üé≤ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–π –∫–æ–¥</button>
                    <div id="analysis-output" class="output" style="display: none;"></div>
                </div>
            </div>
            
            <!-- –≠—Ç–∞–ø 3: –°—Ä–∞–≤–Ω–µ–Ω–∏–µ -->
            <div class="section">
                <div class="section-title">
                    üìä –≠—Ç–∞–ø 3: –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π —Å —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å—é
                </div>
                <div class="card">
                    <p style="margin-bottom: 15px;">
                        –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ —Å —Ä–µ–∞–ª—å–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–¥–∞.
                    </p>
                    <button class="btn" onclick="comparePerformance()">üìä –°—Ä–∞–≤–Ω–∏—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å</button>
                    <div id="comparison-output" class="output" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ========================================================================
        // STAGE 1: LEXER (–õ–µ–∫—Å–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑)
        // ========================================================================
        
        function Lexer(input) {
            this.input = input;
            this.position = 0;
            this.currentChar = this.input[0];
        }
        
        Lexer.prototype.advance = function() {
            this.position++;
            this.currentChar = this.position < this.input.length ? this.input[this.position] : null;
        };
        
        Lexer.prototype.skipWhitespace = function() {
            while (this.currentChar !== null && /\s/.test(this.currentChar)) {
                this.advance();
            }
        };
        
        Lexer.prototype.readNumber = function() {
            var num = '';
            while (this.currentChar !== null && /[0-9.]/.test(this.currentChar)) {
                num += this.currentChar;
                this.advance();
            }
            return parseFloat(num);
        };
        
        Lexer.prototype.readIdentifier = function() {
            var id = '';
            while (this.currentChar !== null && /[a-zA-Z0-9_]/.test(this.currentChar)) {
                id += this.currentChar;
                this.advance();
            }
            return id;
        };
        
        Lexer.prototype.getNextToken = function() {
            while (this.currentChar !== null) {
                if (/\s/.test(this.currentChar)) {
                    this.skipWhitespace();
                    continue;
                }
                
                if (/[0-9]/.test(this.currentChar)) {
                    return { type: 'NUMBER', value: this.readNumber() };
                }
                
                if (/[a-zA-Z_]/.test(this.currentChar)) {
                    var id = this.readIdentifier();
                    var keywords = ['function', 'return', 'if', 'else', 'for', 'while', 'var', 'let', 'const'];
                    if (keywords.indexOf(id) !== -1) {
                        return { type: id.toUpperCase(), value: id };
                    }
                    return { type: 'ID', value: id };
                }
                
                var char = this.currentChar;
                this.advance();
                
                if (char === '+') return { type: 'PLUS', value: '+' };
                if (char === '-') return { type: 'MINUS', value: '-' };
                if (char === '*') return { type: 'MUL', value: '*' };
                if (char === '/') return { type: 'DIV', value: '/' };
                if (char === '(') return { type: 'LPAREN', value: '(' };
                if (char === ')') return { type: 'RPAREN', value: ')' };
                if (char === '{') return { type: 'LBRACE', value: '{' };
                if (char === '}') return { type: 'RBRACE', value: '}' };
                if (char === ';') return { type: 'SEMI', value: ';' };
                if (char === ',') return { type: 'COMMA', value: ',' };
                if (char === '=') {
                    if (this.currentChar === '=') {
                        this.advance();
                        return { type: 'EQ', value: '==' };
                    }
                    return { type: 'ASSIGN', value: '=' };
                }
                if (char === '<') {
                    if (this.currentChar === '=') {
                        this.advance();
                        return { type: 'LTE', value: '<=' };
                    }
                    return { type: 'LT', value: '<' };
                }
                if (char === '>') {
                    if (this.currentChar === '=') {
                        this.advance();
                        return { type: 'GTE', value: '>=' };
                    }
                    return { type: 'GT', value: '>' };
                }
            }
            
            return { type: 'EOF', value: null };
        };
        
        // ========================================================================
        // STAGE 2: PARSER (–°–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑)
        // ========================================================================
        
        function Parser(lexer) {
            this.lexer = lexer;
            this.currentToken = this.lexer.getNextToken();
        }
        
        Parser.prototype.eat = function(tokenType) {
            if (this.currentToken.type === tokenType) {
                this.currentToken = this.lexer.getNextToken();
            } else {
                throw new Error('Unexpected token: ' + this.currentToken.type + ', expected: ' + tokenType);
            }
        };
        
        Parser.prototype.parse = function() {
            var statements = [];
            while (this.currentToken.type !== 'EOF') {
                statements.push(this.statement());
            }
            return { type: 'Program', body: statements };
        };
        
        Parser.prototype.statement = function() {
            if (this.currentToken.type === 'FUNCTION') {
                return this.functionDeclaration();
            } else if (this.currentToken.type === 'VAR' || this.currentToken.type === 'LET' || this.currentToken.type === 'CONST') {
                return this.variableDeclaration();
            } else if (this.currentToken.type === 'RETURN') {
                return this.returnStatement();
            } else if (this.currentToken.type === 'IF') {
                return this.ifStatement();
            } else if (this.currentToken.type === 'FOR') {
                return this.forStatement();
            } else if (this.currentToken.type === 'WHILE') {
                return this.whileStatement();
            } else {
                var expr = this.expression();
                this.eat('SEMI');
                return expr;
            }
        };
        
        Parser.prototype.functionDeclaration = function() {
            this.eat('FUNCTION');
            var name = { type: 'Identifier', value: this.currentToken.value };
            this.eat('ID');
            this.eat('LPAREN');
            
            var params = [];
            if (this.currentToken.type !== 'RPAREN') {
                params.push({ type: 'Identifier', value: this.currentToken.value });
                this.eat('ID');
                while (this.currentToken.type === 'COMMA') {
                    this.eat('COMMA');
                    params.push({ type: 'Identifier', value: this.currentToken.value });
                    this.eat('ID');
                }
            }
            
            this.eat('RPAREN');
            var body = this.blockStatement();
            
            return { type: 'FunctionDeclaration', name: name, params: params, body: body };
        };
        
        Parser.prototype.blockStatement = function() {
            this.eat('LBRACE');
            var statements = [];
            while (this.currentToken.type !== 'RBRACE' && this.currentToken.type !== 'EOF') {
                statements.push(this.statement());
            }
            this.eat('RBRACE');
            return { type: 'BlockStatement', statements: statements };
        };
        
        Parser.prototype.variableDeclaration = function() {
            var kind = this.currentToken.value;
            this.eat(this.currentToken.type);
            var id = { type: 'Identifier', value: this.currentToken.value };
            this.eat('ID');
            
            var init = null;
            if (this.currentToken.type === 'ASSIGN') {
                this.eat('ASSIGN');
                init = this.expression();
            }
            
            this.eat('SEMI');
            return { type: 'VariableDeclaration', kind: kind, id: id, init: init };
        };
        
        Parser.prototype.returnStatement = function() {
            this.eat('RETURN');
            var argument = null;
            if (this.currentToken.type !== 'SEMI') {
                argument = this.expression();
            }
            this.eat('SEMI');
            return { type: 'ReturnStatement', argument: argument };
        };
        
        Parser.prototype.ifStatement = function() {
            this.eat('IF');
            this.eat('LPAREN');
            var test = this.expression();
            this.eat('RPAREN');
            var consequent = this.blockStatement();
            var alternate = null;
            if (this.currentToken.type === 'ELSE') {
                this.eat('ELSE');
                alternate = this.blockStatement();
            }
            return { type: 'IfStatement', test: test, consequent: consequent, alternate: alternate };
        };
        
        Parser.prototype.forStatement = function() {
            this.eat('FOR');
            this.eat('LPAREN');
            var init = this.variableDeclarationForLoop();
            var test = this.expression();
            this.eat('SEMI');
            var update = this.expression();
            this.eat('RPAREN');
            var body = this.blockStatement();
            return { type: 'ForStatement', init: init, test: test, update: update, body: body };
        };
        
        Parser.prototype.variableDeclarationForLoop = function() {
            var kind = this.currentToken.value;
            this.eat(this.currentToken.type);
            var id = { type: 'Identifier', value: this.currentToken.value };
            this.eat('ID');
            var init = null;
            if (this.currentToken.type === 'ASSIGN') {
                this.eat('ASSIGN');
                init = this.expression();
            }
            this.eat('SEMI');
            return { type: 'VariableDeclaration', kind: kind, id: id, init: init };
        };
        
        Parser.prototype.whileStatement = function() {
            this.eat('WHILE');
            this.eat('LPAREN');
            var test = this.expression();
            this.eat('RPAREN');
            var body = this.blockStatement();
            return { type: 'WhileStatement', test: test, body: body };
        };
        
        Parser.prototype.expression = function() {
            return this.comparisonExpression();
        };
        
        Parser.prototype.comparisonExpression = function() {
            var left = this.additiveExpression();
            
            while (this.currentToken.type === 'LT' || this.currentToken.type === 'GT' || 
                   this.currentToken.type === 'LTE' || this.currentToken.type === 'GTE' ||
                   this.currentToken.type === 'EQ') {
                var operator = this.currentToken.value;
                this.eat(this.currentToken.type);
                var right = this.additiveExpression();
                left = { type: 'BinaryExpression', operator: operator, left: left, right: right };
            }
            
            return left;
        };
        
        Parser.prototype.additiveExpression = function() {
            var left = this.multiplicativeExpression();
            
            while (this.currentToken.type === 'PLUS' || this.currentToken.type === 'MINUS') {
                var operator = this.currentToken.value;
                this.eat(this.currentToken.type);
                var right = this.multiplicativeExpression();
                left = { type: 'BinaryExpression', operator: operator, left: left, right: right };
            }
            
            return left;
        };
        
        Parser.prototype.multiplicativeExpression = function() {
            var left = this.primary();
            
            while (this.currentToken.type === 'MUL' || this.currentToken.type === 'DIV') {
                var operator = this.currentToken.value;
                this.eat(this.currentToken.type);
                var right = this.primary();
                left = { type: 'BinaryExpression', operator: operator, left: left, right: right };
            }
            
            return left;
        };
        
        Parser.prototype.primary = function() {
            var token = this.currentToken;
            
            if (token.type === 'NUMBER') {
                this.eat('NUMBER');
                return { type: 'Literal', value: token.value };
            } else if (token.type === 'ID') {
                var id = { type: 'Identifier', value: token.value };
                this.eat('ID');
                
                if (this.currentToken.type === 'LPAREN') {
                    this.eat('LPAREN');
                    var args = [];
                    if (this.currentToken.type !== 'RPAREN') {
                        args.push(this.expression());
                        while (this.currentToken.type === 'COMMA') {
                            this.eat('COMMA');
                            args.push(this.expression());
                        }
                    }
                    this.eat('RPAREN');
                    return { type: 'CallExpression', callee: id, arguments: args };
                } else if (this.currentToken.type === 'ASSIGN') {
                    this.eat('ASSIGN');
                    var right = this.expression();
                    return { type: 'AssignmentExpression', left: id, right: right };
                }
                
                return id;
            } else if (token.type === 'LPAREN') {
                this.eat('LPAREN');
                var expr = this.expression();
                this.eat('RPAREN');
                return expr;
            }
            
            throw new Error('Unexpected token: ' + token.type);
        };
        
        // ========================================================================
        // STAGE 6: CODE FEATURE EXTRACTOR
        // ========================================================================
        
        function CodeFeatureExtractor() {
            this.features = {};
            this.nodeCounts = { total: 0, literals: 0, identifiers: 0, binaryOps: 0, unaryOps: 0, calls: 0, assignments: 0, returns: 0, ifs: 0, loops: 0, functions: 0 };
            this.operationCounts = { arithmetic: 0, comparison: 0, logical: 0, bitwise: 0 };
            this.depthStats = { max: 0, average: 0, samples: [] };
            this.variableStats = { declared: 0, used: 0, usageMap: {} };
            this.loopStats = { total: 0, nested: 0, maxNesting: 0 };
            this.callGraph = { nodes: [], edges: [] };
        }
        
        CodeFeatureExtractor.prototype.extract = function(ast) {
            this.reset();
            this.traverseAST(ast, 0);
            this.computeDerivedFeatures();
            return this.buildFeatureVector();
        };
        
        CodeFeatureExtractor.prototype.reset = function() {
            this.nodeCounts = { total: 0, literals: 0, identifiers: 0, binaryOps: 0, unaryOps: 0, calls: 0, assignments: 0, returns: 0, ifs: 0, loops: 0, functions: 0 };
            this.operationCounts = { arithmetic: 0, comparison: 0, logical: 0, bitwise: 0 };
            this.depthStats = { max: 0, average: 0, samples: [] };
            this.variableStats = { declared: 0, used: 0, usageMap: {} };
            this.loopStats = { total: 0, nested: 0, maxNesting: 0 };
            this.callGraph = { nodes: [], edges: [] };
            this.features = {};
        };
        
        CodeFeatureExtractor.prototype.traverseAST = function(node, depth, loopDepth) {
            if (!node || typeof node !== 'object') return;
            loopDepth = loopDepth || 0;
            
            this.nodeCounts.total++;
            if (depth > this.depthStats.max) this.depthStats.max = depth;
            this.depthStats.samples.push(depth);
            
            var nodeType = node.type;
            
            if (nodeType === 'Program') {
                if (node.body && Array.isArray(node.body)) {
                    for (var i = 0; i < node.body.length; i++) {
                        this.traverseAST(node.body[i], depth + 1, loopDepth);
                    }
                }
            } else if (nodeType === 'FunctionDeclaration') {
                this.nodeCounts.functions++;
                if (node.name) this.callGraph.nodes.push(node.name.value);
                if (node.params) {
                    for (var i = 0; i < node.params.length; i++) {
                        this.traverseAST(node.params[i], depth + 1, loopDepth);
                    }
                }
                if (node.body) this.traverseAST(node.body, depth + 1, loopDepth);
            } else if (nodeType === 'BlockStatement') {
                if (node.statements) {
                    for (var i = 0; i < node.statements.length; i++) {
                        this.traverseAST(node.statements[i], depth + 1, loopDepth);
                    }
                }
            } else if (nodeType === 'VariableDeclaration') {
                this.variableStats.declared++;
                if (node.id && node.id.value) this.variableStats.usageMap[node.id.value] = 0;
                if (node.init) this.traverseAST(node.init, depth + 1, loopDepth);
            } else if (nodeType === 'Identifier') {
                this.nodeCounts.identifiers++;
                if (node.value && this.variableStats.usageMap[node.value] !== undefined) {
                    this.variableStats.usageMap[node.value]++;
                    this.variableStats.used++;
                }
            } else if (nodeType === 'Literal') {
                this.nodeCounts.literals++;
            } else if (nodeType === 'BinaryExpression') {
                this.nodeCounts.binaryOps++;
                this.classifyOperation(node.operator);
                if (node.left) this.traverseAST(node.left, depth + 1, loopDepth);
                if (node.right) this.traverseAST(node.right, depth + 1, loopDepth);
            } else if (nodeType === 'AssignmentExpression') {
                this.nodeCounts.assignments++;
                if (node.left) this.traverseAST(node.left, depth + 1, loopDepth);
                if (node.right) this.traverseAST(node.right, depth + 1, loopDepth);
            } else if (nodeType === 'CallExpression') {
                this.nodeCounts.calls++;
                if (node.callee && node.callee.value) {
                    this.callGraph.edges.push({ from: 'current', to: node.callee.value });
                }
                if (node.arguments) {
                    for (var i = 0; i < node.arguments.length; i++) {
                        this.traverseAST(node.arguments[i], depth + 1, loopDepth);
                    }
                }
            } else if (nodeType === 'ReturnStatement') {
                this.nodeCounts.returns++;
                if (node.argument) this.traverseAST(node.argument, depth + 1, loopDepth);
            } else if (nodeType === 'IfStatement') {
                this.nodeCounts.ifs++;
                if (node.test) this.traverseAST(node.test, depth + 1, loopDepth);
                if (node.consequent) this.traverseAST(node.consequent, depth + 1, loopDepth);
                if (node.alternate) this.traverseAST(node.alternate, depth + 1, loopDepth);
            } else if (nodeType === 'WhileStatement' || nodeType === 'ForStatement') {
                this.nodeCounts.loops++;
                this.loopStats.total++;
                if (loopDepth > 0) this.loopStats.nested++;
                var newLoopDepth = loopDepth + 1;
                if (newLoopDepth > this.loopStats.maxNesting) this.loopStats.maxNesting = newLoopDepth;
                if (node.test) this.traverseAST(node.test, depth + 1, newLoopDepth);
                if (node.init) this.traverseAST(node.init, depth + 1, newLoopDepth);
                if (node.update) this.traverseAST(node.update, depth + 1, newLoopDepth);
                if (node.body) this.traverseAST(node.body, depth + 1, newLoopDepth);
            }
        };
        
        CodeFeatureExtractor.prototype.classifyOperation = function(operator) {
            var arithmetic = ['+', '-', '*', '/', '%'];
            var comparison = ['==', '!=', '<', '>', '<=', '>='];
            var logical = ['&&', '||'];
            var bitwise = ['&', '|', '^', '<<', '>>', '>>>'];
            
            if (arithmetic.indexOf(operator) !== -1) {
                this.operationCounts.arithmetic++;
            } else if (comparison.indexOf(operator) !== -1) {
                this.operationCounts.comparison++;
            } else if (logical.indexOf(operator) !== -1) {
                this.operationCounts.logical++;
            } else if (bitwise.indexOf(operator) !== -1) {
                this.operationCounts.bitwise++;
            }
        };
        
        CodeFeatureExtractor.prototype.computeDerivedFeatures = function() {
            if (this.depthStats.samples.length > 0) {
                var sum = 0;
                for (var i = 0; i < this.depthStats.samples.length; i++) {
                    sum += this.depthStats.samples[i];
                }
                this.depthStats.average = sum / this.depthStats.samples.length;
            }
            
            this.features.branchingFactor = this.nodeCounts.total > 0 ? this.nodeCounts.ifs / this.nodeCounts.total : 0;
            
            var totalOps = this.operationCounts.arithmetic + this.operationCounts.comparison + this.operationCounts.logical + this.operationCounts.bitwise;
            this.features.operationDensity = this.nodeCounts.total > 0 ? totalOps / this.nodeCounts.total : 0;
            
            if (totalOps > 0) {
                this.features.arithmeticRatio = this.operationCounts.arithmetic / totalOps;
                this.features.comparisonRatio = this.operationCounts.comparison / totalOps;
                this.features.logicalRatio = this.operationCounts.logical / totalOps;
                this.features.bitwiseRatio = this.operationCounts.bitwise / totalOps;
            } else {
                this.features.arithmeticRatio = 0;
                this.features.comparisonRatio = 0;
                this.features.logicalRatio = 0;
                this.features.bitwiseRatio = 0;
            }
            
            var totalUsages = 0;
            var variableNames = Object.keys(this.variableStats.usageMap);
            for (var i = 0; i < variableNames.length; i++) {
                totalUsages += this.variableStats.usageMap[variableNames[i]];
            }
            this.features.variableReuseRate = this.variableStats.declared > 0 ? totalUsages / this.variableStats.declared : 0;
            this.features.loopComplexity = this.loopStats.total > 0 ? (this.loopStats.nested + this.loopStats.maxNesting) / this.loopStats.total : 0;
            this.features.cyclomaticComplexity = 1 + this.nodeCounts.ifs + this.nodeCounts.loops;
        };
        
        CodeFeatureExtractor.prototype.buildFeatureVector = function() {
            return [
                this.nodeCounts.total, this.depthStats.max, this.depthStats.average, this.features.branchingFactor,
                this.nodeCounts.literals, this.nodeCounts.identifiers, this.nodeCounts.binaryOps, this.nodeCounts.unaryOps,
                this.nodeCounts.calls, this.nodeCounts.assignments, this.nodeCounts.returns, this.nodeCounts.ifs,
                this.nodeCounts.loops, this.nodeCounts.functions, this.operationCounts.arithmetic, this.operationCounts.comparison,
                this.operationCounts.logical, this.operationCounts.bitwise, this.features.operationDensity, this.features.arithmeticRatio,
                this.features.comparisonRatio, this.features.logicalRatio, this.features.bitwiseRatio, this.variableStats.declared,
                this.variableStats.used, this.features.variableReuseRate, this.loopStats.total, this.loopStats.nested,
                this.loopStats.maxNesting, this.features.loopComplexity, this.features.cyclomaticComplexity,
                this.callGraph.nodes.length, this.callGraph.edges.length
            ];
        };
        
        // ========================================================================
        // STAGE 6: NEURAL NETWORK
        // ========================================================================
        
        function NeuralNetwork(layerSizes) {
            this.layerSizes = layerSizes;
            this.numLayers = layerSizes.length;
            this.weights = [];
            this.biases = [];
            this.activations = [];
            this.zValues = [];
            this.learningRate = 0.001;
            this.momentum = 0.9;
            this.trainingHistory = { losses: [], epochs: 0 };
            this.initializeWeights();
        }
        
        NeuralNetwork.prototype.initializeWeights = function() {
            for (var i = 0; i < this.numLayers - 1; i++) {
                var inputSize = this.layerSizes[i];
                var outputSize = this.layerSizes[i + 1];
                var layerWeights = [];
                var scale = Math.sqrt(2.0 / (inputSize + outputSize));
                
                for (var j = 0; j < outputSize; j++) {
                    var neuronWeights = [];
                    for (var k = 0; k < inputSize; k++) {
                        neuronWeights.push((Math.random() * 2 - 1) * scale);
                    }
                    layerWeights.push(neuronWeights);
                }
                
                this.weights.push(layerWeights);
                
                var layerBiases = [];
                for (var j = 0; j < outputSize; j++) {
                    layerBiases.push(0);
                }
                
                this.biases.push(layerBiases);
            }
        };
        
        NeuralNetwork.prototype.forward = function(input) {
            this.activations = [];
            this.zValues = [];
            this.activations.push(input);
            
            for (var layer = 0; layer < this.weights.length; layer++) {
                var prevActivation = this.activations[layer];
                var layerWeights = this.weights[layer];
                var layerBiases = this.biases[layer];
                
                var z = [];
                var a = [];
                
                for (var neuron = 0; neuron < layerWeights.length; neuron++) {
                    var neuronWeights = layerWeights[neuron];
                    var neuronBias = layerBiases[neuron];
                    
                    var sum = neuronBias;
                    for (var i = 0; i < prevActivation.length; i++) {
                        sum += neuronWeights[i] * prevActivation[i];
                    }
                    
                    z.push(sum);
                    
                    var activation;
                    if (layer < this.weights.length - 1) {
                        activation = this.relu(sum);
                    } else {
                        activation = sum;
                    }
                    
                    a.push(activation);
                }
                
                this.zValues.push(z);
                this.activations.push(a);
            }
            
            var output = this.activations[this.activations.length - 1];
            return output[0];
        };
        
        NeuralNetwork.prototype.relu = function(x) {
            return Math.max(0, x);
        };
        
        NeuralNetwork.prototype.reluDerivative = function(x) {
            return x > 0 ? 1 : 0;
        };
        
        NeuralNetwork.prototype.computeLoss = function(predicted, actual) {
            var diff = predicted - actual;
            return diff * diff;
        };
        
        NeuralNetwork.prototype.trainOnce = function(input, target) {
            var predicted = this.forward(input);
            var loss = this.computeLoss(predicted, target);
            this.backward(target);
            this.updateWeights();
            return loss;
        };
        
        NeuralNetwork.prototype.backward = function(target) {
            this.weightGradients = [];
            this.biasGradients = [];
            
            for (var i = 0; i < this.weights.length; i++) {
                var layerWeightGrads = [];
                var layerBiasGrads = [];
                
                for (var j = 0; j < this.weights[i].length; j++) {
                    var neuronGrads = [];
                    for (var k = 0; k < this.weights[i][j].length; k++) {
                        neuronGrads.push(0);
                    }
                    layerWeightGrads.push(neuronGrads);
                    layerBiasGrads.push(0);
                }
                
                this.weightGradients.push(layerWeightGrads);
                this.biasGradients.push(layerBiasGrads);
            }
            
            var outputLayer = this.weights.length - 1;
            var predicted = this.activations[this.activations.length - 1][0];
            var outputError = 2 * (predicted - target);
            var delta = [outputError];
            
            for (var layer = this.weights.length - 1; layer >= 0; layer--) {
                var prevActivation = this.activations[layer];
                var layerWeights = this.weights[layer];
                
                for (var neuron = 0; neuron < layerWeights.length; neuron++) {
                    this.biasGradients[layer][neuron] = delta[neuron];
                    
                    for (var weight = 0; weight < layerWeights[neuron].length; weight++) {
                        this.weightGradients[layer][neuron][weight] = delta[neuron] * prevActivation[weight];
                    }
                }
                
                if (layer > 0) {
                    var nextDelta = [];
                    
                    for (var i = 0; i < prevActivation.length; i++) {
                        var error = 0;
                        
                        for (var j = 0; j < layerWeights.length; j++) {
                            error += delta[j] * layerWeights[j][i];
                        }
                        
                        var z = this.zValues[layer - 1][i];
                        error *= this.reluDerivative(z);
                        
                        nextDelta.push(error);
                    }
                    
                    delta = nextDelta;
                }
            }
        };
        
        NeuralNetwork.prototype.updateWeights = function() {
            for (var layer = 0; layer < this.weights.length; layer++) {
                for (var neuron = 0; neuron < this.weights[layer].length; neuron++) {
                    this.biases[layer][neuron] -= this.learningRate * this.biasGradients[layer][neuron];
                    
                    for (var weight = 0; weight < this.weights[layer][neuron].length; weight++) {
                        this.weights[layer][neuron][weight] -= this.learningRate * this.weightGradients[layer][neuron][weight];
                    }
                }
            }
        };
        
        NeuralNetwork.prototype.train = function(trainingData, epochs, callback) {
            for (var epoch = 0; epoch < epochs; epoch++) {
                var totalLoss = 0;
                var shuffled = this.shuffleArray(trainingData.slice());
                
                for (var i = 0; i < shuffled.length; i++) {
                    var sample = shuffled[i];
                    var loss = this.trainOnce(sample.input, sample.target);
                    totalLoss += loss;
                }
                
                var avgLoss = totalLoss / shuffled.length;
                this.trainingHistory.losses.push(avgLoss);
                this.trainingHistory.epochs++;
                
                if (callback && (epoch + 1) % Math.max(1, Math.floor(epochs / 10)) === 0) {
                    callback(epoch + 1, epochs, avgLoss);
                }
            }
            
            return {
                finalLoss: this.trainingHistory.losses[this.trainingHistory.losses.length - 1],
                history: this.trainingHistory
            };
        };
        
        NeuralNetwork.prototype.predict = function(input) {
            return this.forward(input);
        };
        
        NeuralNetwork.prototype.shuffleArray = function(array) {
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            return array;
        };
        
        // ========================================================================
        // TRAINING DATA GENERATOR
        // ========================================================================
        
        function generateTrainingData(numSamples) {
            var samples = [];
            var extractor = new CodeFeatureExtractor();
            
            for (var i = 0; i < numSamples; i++) {
                var code = generateRandomFunction();
                
                try {
                    var lexer = new Lexer(code);
                    var parser = new Parser(lexer);
                    var ast = parser.parse();
                    
                    var features = extractor.extract(ast);
                    
                    // –ò–∑–º–µ—Ä—è–µ–º —Ä–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
                    var executionTime = measureExecutionTime(code);
                    
                    samples.push({
                        input: features,
                        target: executionTime,
                        code: code
                    });
                } catch (e) {
                    // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π –∫–æ–¥
                    i--;
                }
            }
            
            return samples;
        }
        
        function generateRandomFunction() {
            // –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –∫–æ–ª–ª–µ–∫—Ü–∏—è —à–∞–±–ª–æ–Ω–æ–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ 500 —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä–æ–≤
            // –ö–∞–∂–¥—ã–π —à–∞–±–ª–æ–Ω –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–∞–∑–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —É—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
            
            var templates = [
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 1: –ü—Ä–æ—Å—Ç—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Å –æ–¥–Ω–∏–º —Ü–∏–∫–ª–æ–º
                'function test() { var sum = 0; for (var i = 0; i < 100; i = i + 1) { sum = sum + i; } return sum; }',
                'function test() { var sum = 0; for (var i = 0; i < 50; i = i + 1) { sum = sum + i * 2; } return sum; }',
                'function test() { var product = 1; for (var i = 1; i < 20; i = i + 1) { product = product * i; } return product; }',
                'function test() { var sum = 0; for (var i = 0; i < 200; i = i + 2) { sum = sum + i; } return sum; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 2: –§—É–Ω–∫—Ü–∏–∏ —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ —Ü–∏–∫–ª–∞–º–∏ (–≤—ã—Å–æ–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å)
                'function test() { var sum = 0; for (var i = 0; i < 10; i = i + 1) { for (var j = 0; j < 10; j = j + 1) { sum = sum + i * j; } } return sum; }',
                'function test() { var sum = 0; for (var i = 0; i < 15; i = i + 1) { for (var j = 0; j < 15; j = j + 1) { sum = sum + i + j; } } return sum; }',
                'function test() { var sum = 0; for (var i = 0; i < 20; i = i + 1) { for (var j = 0; j < 10; j = j + 1) { sum = sum + i - j; } } return sum; }',
                'function test() { var result = 0; for (var i = 1; i < 8; i = i + 1) { for (var j = 1; j < 8; j = j + 1) { result = result + i * j + i; } } return result; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 3: –§—É–Ω–∫—Ü–∏–∏ —Å —É—Å–ª–æ–≤–∏—è–º–∏ (—Å—Ä–µ–¥–Ω—è—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å)
                'function test() { var sum = 0; for (var i = 0; i < 50; i = i + 1) { if (i < 25) { sum = sum + i; } } return sum; }',
                'function test() { var sum = 0; for (var i = 0; i < 100; i = i + 1) { if (i < 50) { sum = sum + i * 2; } else { sum = sum + i; } } return sum; }',
                'function test() { var count = 0; for (var i = 0; i < 100; i = i + 1) { if (i < 30) { count = count + 1; } } return count; }',
                'function test() { var sum = 0; for (var i = 0; i < 80; i = i + 1) { if (i < 40) { sum = sum + i; } else { sum = sum - i; } } return sum; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 4: –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (–æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å)
                'function fib(n) { if (n < 2) { return n; } return fib(n - 1) + fib(n - 2); }',
                'function factorial(n) { if (n < 2) { return 1; } return n * factorial(n - 1); }',
                'function countdown(n) { if (n < 1) { return 0; } return n + countdown(n - 1); }',
                'function power(base, exp) { if (exp < 1) { return 1; } return base * power(base, exp - 1); }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 5: –§—É–Ω–∫—Ü–∏–∏ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
                'function test() { var a = 10; var b = 20; var c = a * b + a - b; var d = c / 2; return d; }',
                'function test() { var x = 5; var y = 15; var z = x * y * 2 + x / 2 - y; return z; }',
                'function test() { var a = 7; var b = 3; var result = a * a + b * b - a * b; return result; }',
                'function test() { var x = 100; var y = 50; var z = x / y + x * y - x + y; return z; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 6: –§—É–Ω–∫—Ü–∏–∏ —Å —Ü–∏–∫–ª–∞–º–∏ while
                'function test() { var i = 0; var sum = 0; while (i < 100) { sum = sum + i; i = i + 1; } return sum; }',
                'function test() { var i = 0; var product = 1; while (i < 10) { product = product * 2; i = i + 1; } return product; }',
                'function test() { var i = 100; var sum = 0; while (i < 0) { sum = sum + i; i = i - 1; } return sum; }',
                'function test() { var i = 1; var sum = 0; while (i < 50) { sum = sum + i * 2; i = i + 2; } return sum; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 7: –§—É–Ω–∫—Ü–∏–∏ —Å –∫–æ–º–±–∏–Ω–∞—Ü–∏–µ–π —Ü–∏–∫–ª–æ–≤ –∏ —É—Å–ª–æ–≤–∏–π
                'function test() { var sum = 0; for (var i = 0; i < 100; i = i + 1) { if (i < 25) { sum = sum + i; } else { if (i < 75) { sum = sum + i * 2; } } } return sum; }',
                'function test() { var count = 0; for (var i = 0; i < 50; i = i + 1) { if (i < 10) { count = count + 1; } else { if (i < 40) { count = count + 2; } } } return count; }',
                'function test() { var result = 0; for (var i = 0; i < 60; i = i + 1) { if (i < 20) { result = result + i; } else { result = result - i; } } return result; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 8: –¢—Ä–æ–π–Ω—ã–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Ü–∏–∫–ª—ã (—ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å)
                'function test() { var sum = 0; for (var i = 0; i < 5; i = i + 1) { for (var j = 0; j < 5; j = j + 1) { for (var k = 0; k < 5; k = k + 1) { sum = sum + i + j + k; } } } return sum; }',
                'function test() { var product = 1; for (var i = 1; i < 4; i = i + 1) { for (var j = 1; j < 4; j = j + 1) { for (var k = 1; k < 4; k = k + 1) { product = product + i * j * k; } } } return product; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 9: –§—É–Ω–∫—Ü–∏–∏ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é (–±–∞–∑–æ–≤–∞—è –ª–∏–Ω–∏—è)
                'function test() { var a = 5; var b = 10; return a + b; }',
                'function test() { var x = 100; return x * 2; }',
                'function test() { var result = 42; return result; }',
                'function test() { return 10 + 20 * 30; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 10: –§—É–Ω–∫—Ü–∏–∏ —Å–æ —Å—Ä–µ–¥–Ω–µ–π —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é –∏ —Ä–∞–∑–Ω—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏
                'function test() { var sum = 0; for (var i = 0; i < 30; i = i + 1) { sum = sum + i * 3 - i / 2; } return sum; }',
                'function test() { var result = 0; for (var i = 5; i < 55; i = i + 5) { result = result + i; } return result; }',
                'function test() { var x = 0; for (var i = 10; i < 0; i = i - 1) { x = x + i; } return x; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 11: –§—É–Ω–∫—Ü–∏–∏ —Å –∫–æ–º–±–∏–Ω–∞—Ü–∏–µ–π –æ–ø–µ—Ä–∞—Ü–∏–π —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
                'function test() { var count = 0; for (var i = 0; i < 100; i = i + 1) { if (i < 25) { count = count + 1; } if (i < 75) { count = count + 1; } } return count; }',
                'function test() { var sum = 0; for (var i = 0; i < 50; i = i + 1) { if (i < 10) { sum = sum + 5; } if (i < 40) { sum = sum + 10; } } return sum; }',
                
                // –ö–ê–¢–ï–ì–û–†–ò–Ø 12: –°–º–µ—à–∞–Ω–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
                'function test() { var a = 0; for (var i = 0; i < 20; i = i + 1) { a = a + i; for (var j = 0; j < 5; j = j + 1) { a = a + j; } } return a; }',
                'function test() { var sum = 0; var i = 0; while (i < 50) { if (i < 25) { sum = sum + i * 2; } else { sum = sum + i; } i = i + 1; } return sum; }',
                'function test() { var result = 1; for (var i = 2; i < 10; i = i + 1) { result = result * i; if (result < 100) { result = result + i; } } return result; }'
            ];
            
            // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —à–∞–±–ª–æ–Ω
            var template = templates[Math.floor(Math.random() * templates.length)];
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å: –∏–Ω–æ–≥–¥–∞ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º —á–∏—Å–ª–∞ –≤ —à–∞–±–ª–æ–Ω–µ
            if (Math.random() < 0.3) {
                // –ò–∑–º–µ–Ω—è–µ–º —á–∏—Å–ª–æ–≤—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –µ—â—ë –±–æ–ª—å—à–µ–≥–æ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
                template = template.replace(/100/g, function() {
                    return Math.floor(Math.random() * 150) + 50;
                });
                template = template.replace(/50/g, function() {
                    return Math.floor(Math.random() * 80) + 20;
                });
            }
            
            return template;
        }
        
        function measureExecutionTime(code) {
            // –£–ª—É—á—à–µ–Ω–Ω–∞—è —ç–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∞—è –æ—Ü–µ–Ω–∫–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∫–æ–¥–∞
            // –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–æ–¥ –∏ –ø—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç –µ–≥–æ –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å
            // –í –∏–¥–µ–∞–ª—å–Ω–æ–º –º–∏—Ä–µ –º—ã –±—ã –≤—ã–ø–æ–ª–Ω—è–ª–∏ –∫–æ–¥ –∏ –∑–∞–º–µ—Ä—è–ª–∏ —Ä–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è,
            // –Ω–æ —ç—Ç–æ –æ–ø–∞—Å–Ω–æ (–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–µ —Ü–∏–∫–ª—ã) –∏ –º–µ–¥–ª–µ–Ω–Ω–æ –¥–ª—è 500 –ø—Ä–∏–º–µ—Ä–æ–≤
            
            var complexity = 0;
            
            // ============================================================
            // –ê–ù–ê–õ–ò–ó –¶–ò–ö–õ–û–í - —Å–∞–º—ã–π –≤–∞–∂–Ω—ã–π —Ñ–∞–∫—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            // ============================================================
            
            // –ü—Ä–æ—Å—Ç—ã–µ —Ü–∏–∫–ª—ã for
            var forLoops = (code.match(/for\s*\(/g) || []).length;
            
            // –¶–∏–∫–ª—ã while
            var whileLoops = (code.match(/while\s*\(/g) || []).length;
            
            var totalLoops = forLoops + whileLoops;
            
            // –û—Ü–µ–Ω–∏–≤–∞–µ–º –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å —Ü–∏–∫–ª–æ–≤ (–∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞—è –∏–ª–∏ –∫—É–±–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å)
            var braceDepth = 0;
            var maxDepth = 0;
            var depthAtLoop = [];
            
            for (var i = 0; i < code.length; i++) {
                if (code[i] === '{') {
                    braceDepth++;
                    maxDepth = Math.max(maxDepth, braceDepth);
                } else if (code[i] === '}') {
                    braceDepth--;
                }
                
                // –ï—Å–ª–∏ –Ω–∞—Ö–æ–¥–∏–º —Ü–∏–∫–ª, –∑–∞–ø–æ–º–∏–Ω–∞–µ–º —Ç–µ–∫—É—â—É—é –≥–ª—É–±–∏–Ω—É
                if (code.substring(i, i + 3) === 'for' || code.substring(i, i + 5) === 'while') {
                    depthAtLoop.push(braceDepth);
                }
            }
            
            // –í—ã—á–∏—Å–ª—è–µ–º —Å—Ä–µ–¥–Ω—é—é –≥–ª—É–±–∏–Ω—É —Ü–∏–∫–ª–æ–≤
            var avgLoopDepth = 0;
            if (depthAtLoop.length > 0) {
                var sum = 0;
                for (var i = 0; i < depthAtLoop.length; i++) {
                    sum += depthAtLoop[i];
                }
                avgLoopDepth = sum / depthAtLoop.length;
            }
            
            // –ë–∞–∑–æ–≤–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –æ—Ç —Ü–∏–∫–ª–æ–≤: O(n)
            complexity += totalLoops * 8;
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –æ—Ç –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏: O(n¬≤) –∏–ª–∏ O(n¬≥)
            // –ï—Å–ª–∏ —Ü–∏–∫–ª—ã –≤–ª–æ–∂–µ–Ω—ã, —Å–ª–æ–∂–Ω–æ—Å—Ç—å —Ä–∞—Å—Ç—ë—Ç —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ
            if (totalLoops > 1) {
                // –í–ª–æ–∂–µ–Ω–Ω—ã–µ —Ü–∏–∫–ª—ã - —ç—Ç–æ –û–ß–ï–ù–¨ –¥–æ—Ä–æ–≥–æ
                var nestingPenalty = Math.pow(totalLoops, 1.8) * 15;
                complexity += nestingPenalty;
            }
            
            // ============================================================
            // –ê–ù–ê–õ–ò–ó –†–ï–ö–£–†–°–ò–ò - —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å
            // ============================================================
            
            // –ò—â–µ–º —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–µ –≤—ã–∑–æ–≤—ã (—Ñ—É–Ω–∫—Ü–∏—è –≤—ã–∑—ã–≤–∞–µ—Ç —Å–∞–º–∞ —Å–µ–±—è)
            var functionNameMatch = code.match(/function\s+(\w+)/);
            if (functionNameMatch) {
                var functionName = functionNameMatch[1];
                var recursiveCalls = (code.match(new RegExp('return.*' + functionName + '\\s*\\(', 'g')) || []).length;
                
                if (recursiveCalls > 0) {
                    // –†–µ–∫—É—Ä—Å–∏—è –û–ß–ï–ù–¨ –¥–æ—Ä–æ–≥–∞—è - –æ—Å–æ–±–µ–Ω–Ω–æ –µ—Å–ª–∏ –¥–≤–∞ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö –≤—ã–∑–æ–≤–∞ (–∫–∞–∫ –§–∏–±–æ–Ω–∞—á—á–∏)
                    // –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å O(2^n)
                    complexity += recursiveCalls * 40;
                    
                    // –ï—Å–ª–∏ –¥–≤–∞ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö –≤—ã–∑–æ–≤–∞ - —ç—Ç–æ –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞ –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                    if (recursiveCalls >= 2) {
                        complexity += 80;
                    }
                }
            }
            
            // ============================================================
            // –ê–ù–ê–õ–ò–ó –£–°–õ–û–í–ù–´–• –û–ü–ï–†–ê–¢–û–†–û–í - –≤–µ—Ç–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
            // ============================================================
            
            var ifs = (code.match(/if\s*\(/g) || []).length;
            var elses = (code.match(/else/g) || []).length;
            
            // –ö–∞–∂–¥–æ–µ —É—Å–ª–æ–≤–∏–µ –¥–æ–±–∞–≤–ª—è–µ—Ç –Ω–µ–±–æ–ª—å—à—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å
            // –ü–ª—é—Å –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –≤–µ—Ç–≤–ª–µ–Ω–∏–π –≤ CPU
            complexity += ifs * 2;
            complexity += elses * 1.5;
            
            // –ï—Å–ª–∏ –º–Ω–æ–≥–æ —É—Å–ª–æ–≤–∏–π –≤–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–æ–≤ - –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —à—Ç—Ä–∞—Ñ
            if (ifs > 2 && totalLoops > 0) {
                complexity += ifs * totalLoops * 0.5;
            }
            
            // ============================================================
            // –ê–ù–ê–õ–ò–ó –ê–†–ò–§–ú–ï–¢–ò–ß–ï–°–ö–ò–• –û–ü–ï–†–ê–¶–ò–ô
            // ============================================================
            
            // –°—á–∏—Ç–∞–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
            var additions = (code.match(/\s\+\s/g) || []).length;
            var subtractions = (code.match(/\s-\s/g) || []).length;
            var multiplications = (code.match(/\s\*\s/g) || []).length;
            var divisions = (code.match(/\s\/\s/g) || []).length;
            
            // –£–º–Ω–æ–∂–µ–Ω–∏–µ –∏ –¥–µ–ª–µ–Ω–∏–µ –¥–æ—Ä–æ–∂–µ —Å–ª–æ–∂–µ–Ω–∏—è –∏ –≤—ã—á–∏—Ç–∞–Ω–∏—è
            complexity += (additions + subtractions) * 0.1;
            complexity += (multiplications + divisions) * 0.3;
            
            // –ï—Å–ª–∏ –º–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ü–∏–π –≤–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–æ–≤ - —É–º–Ω–æ–∂–∞–µ–º –≤–ª–∏—è–Ω–∏–µ
            var totalOperations = additions + subtractions + multiplications + divisions;
            if (totalOperations > 5 && totalLoops > 0) {
                complexity += totalOperations * totalLoops * 0.2;
            }
            
            // ============================================================
            // –ê–ù–ê–õ–ò–ó –°–õ–û–ñ–ù–û–°–¢–ò –ü–†–ò–°–í–ê–ò–í–ê–ù–ò–ô –ò –ü–ï–†–ï–ú–ï–ù–ù–´–•
            // ============================================================
            
            var assignments = (code.match(/=\s/g) || []).length;
            complexity += assignments * 0.15;
            
            // –°—á–∏—Ç–∞–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
            var varDeclarations = (code.match(/var\s+/g) || []).length;
            complexity += varDeclarations * 0.1;
            
            // ============================================================
            // –ê–ù–ê–õ–ò–ó –î–ò–ê–ü–ê–ó–û–ù–û–í –¶–ò–ö–õ–û–í (–∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –≤ —É—Å–ª–æ–≤–∏—è—Ö)
            // ============================================================
            
            // –ò—â–µ–º —á–∏—Å–ª–æ–≤—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –≤ —É—Å–ª–æ–≤–∏—è—Ö —Ü–∏–∫–ª–æ–≤
            var loopConstants = code.match(/i\s*<\s*(\d+)/g);
            if (loopConstants) {
                for (var i = 0; i < loopConstants.length; i++) {
                    var match = loopConstants[i].match(/\d+/);
                    if (match) {
                        var loopSize = parseInt(match[0]);
                        // –ß–µ–º –±–æ–ª—å—à–µ –∏—Ç–µ—Ä–∞—Ü–∏–π, —Ç–µ–º –≤—ã—à–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å
                        complexity += Math.log10(loopSize + 1) * 2;
                    }
                }
            }
            
            // ============================================================
            // –ë–ê–ó–û–í–ê–Ø –°–õ–û–ñ–ù–û–°–¢–¨
            // ============================================================
            
            // –î–∞–∂–µ –ø—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∏–º–µ–µ—Ç –±–∞–∑–æ–≤—É—é —Å—Ç–æ–∏–º–æ—Å—Ç—å –≤—ã–∑–æ–≤–∞
            complexity += 1;
            
            // –î–ª–∏–Ω–∞ –∫–æ–¥–∞ –∫–∞–∫ –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
            complexity += code.length * 0.002;
            
            // ============================================================
            // –î–û–ë–ê–í–õ–Ø–ï–ú –†–ï–ê–õ–ò–°–¢–ò–ß–ù–´–ô –®–£–ú
            // ============================================================
            
            // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ–≥–¥–∞ –Ω–µ–º–Ω–æ–≥–æ –≤–∞—Ä—å–∏—Ä—É–µ—Ç—Å—è
            // –∏–∑-–∑–∞ –∫—ç—à–∞ CPU, –¥—Ä—É–≥–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤, —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞ –∏ —Ç.–¥.
            var noise = (Math.random() - 0.5) * complexity * 0.1;
            complexity += noise;
            
            // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            complexity = Math.max(0.1, complexity);
            
            return complexity;
        }
        
        // ========================================================================
        // UI FUNCTIONS
        // ========================================================================
        
        var globalNetwork = null;
        var globalTrainingData = [];
        
        function trainNetwork(epochs) {
            var outputDiv = document.getElementById('training-output');
            var statsDiv = document.getElementById('training-stats');
            var progressBar = document.getElementById('training-progress');
            var progressFill = document.getElementById('training-progress-fill');
            
            outputDiv.style.display = 'block';
            statsDiv.style.display = 'none';
            progressBar.style.display = 'block';
            
            outputDiv.innerHTML = '<span class="info">‚è≥ –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ...</span>';
            progressFill.style.width = '0%';
            progressFill.textContent = '0%';
            
            setTimeout(function() {
                try {
                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ - –£–í–ï–õ–ò–ß–ï–ù–û –î–û 500 –ü–†–ò–ú–ï–†–û–í
                    var numSamples = 500;
                    outputDiv.innerHTML += '\n<span class="info">‚úì –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º ' + numSamples + ' –ø—Ä–∏–º–µ—Ä–æ–≤ –∫–æ–¥–∞...</span>';
                    outputDiv.innerHTML += '\n<span class="info">  –≠—Ç–æ –∑–∞–π–º—ë—Ç –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ - —Å–æ–∑–¥–∞—ë–º —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã–π –Ω–∞–±–æ—Ä —Ñ—É–Ω–∫—Ü–∏–π...</span>';
                    
                    progressFill.style.width = '10%';
                    progressFill.textContent = '10% - –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö';
                    
                    globalTrainingData = generateTrainingData(numSamples);
                    outputDiv.innerHTML += '\n<span class="success">‚úì –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ ' + globalTrainingData.length + ' –ø—Ä–∏–º–µ—Ä–æ–≤!</span>';
                    outputDiv.innerHTML += '\n<span class="success">  –ö–∞–∂–¥—ã–π –ø—Ä–∏–º–µ—Ä —Å–æ–¥–µ—Ä–∂–∏—Ç 33 —á–∏—Å–ª–æ–≤—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∫–æ–¥–∞</span>';
                    
                    progressFill.style.width = '15%';
                    progressFill.textContent = '15% - –î–∞–Ω–Ω—ã–µ –≥–æ—Ç–æ–≤—ã';
                    
                    // –°–æ–∑–¥–∞—ë–º –Ω–µ–π—Ä–æ—Å–µ—Ç—å
                    // –í–µ–∫—Ç–æ—Ä —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ –∏–º–µ–µ—Ç 33 —ç–ª–µ–º–µ–Ω—Ç–∞
                    globalNetwork = new NeuralNetwork([33, 64, 32, 1]);
                    outputDiv.innerHTML += '\n<span class="info">‚úì –°–æ–∑–¥–∞–Ω–∞ –Ω–µ–π—Ä–æ—Å–µ—Ç—å: [33 ‚Üí 64 ‚Üí 32 ‚Üí 1]</span>';
                    outputDiv.innerHTML += '\n<span class="info">  ‚Ä¢ –í—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π: 33 –Ω–µ–π—Ä–æ–Ω–∞ (—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∫–æ–¥–∞)</span>';
                    outputDiv.innerHTML += '\n<span class="info">  ‚Ä¢ –°–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π 1: 64 –Ω–µ–π—Ä–æ–Ω–∞ (–ø–æ–∏—Å–∫ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤)</span>';
                    outputDiv.innerHTML += '\n<span class="info">  ‚Ä¢ –°–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π 2: 32 –Ω–µ–π—Ä–æ–Ω–∞ (–∞–±—Å—Ç—Ä–∞–∫—Ü–∏—è)</span>';
                    outputDiv.innerHTML += '\n<span class="info">  ‚Ä¢ –í—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π: 1 –Ω–µ–π—Ä–æ–Ω (–ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏)</span>';
                    outputDiv.innerHTML += '\n\n<span class="info">‚è≥ –ù–∞—á–∏–Ω–∞–µ–º –æ–±—É—á–µ–Ω–∏–µ –Ω–∞ ' + epochs + ' —ç–ø–æ—Ö...</span>';
                    outputDiv.innerHTML += '\n<span class="info">  –° ' + numSamples + ' –ø—Ä–∏–º–µ—Ä–∞–º–∏ —ç—Ç–æ –±—É–¥–µ—Ç ' + (numSamples * epochs).toLocaleString() + ' –∏—Ç–µ—Ä–∞—Ü–∏–π –æ–±—É—á–µ–Ω–∏—è!</span>\n';
                    
                    progressFill.style.width = '20%';
                    progressFill.textContent = '20% - –°–µ—Ç—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞';
                    
                    // –û–±—É—á–∞–µ–º
                    var result = globalNetwork.train(globalTrainingData, epochs, function(epoch, total, loss) {
                        var progress = ((epoch / total) * 100).toFixed(1);
                        var barProgress = 20 + (epoch / total) * 75; // –û—Ç 20% –¥–æ 95%
                        
                        progressFill.style.width = barProgress.toFixed(1) + '%';
                        progressFill.textContent = progress + '% - –≠–ø–æ—Ö–∞ ' + epoch + '/' + total;
                        
                        outputDiv.innerHTML += '\n<span class="info">–≠–ø–æ—Ö–∞ ' + epoch + '/' + total + ' (' + progress + '%) - –û—à–∏–±–∫–∞: ' + loss.toFixed(6) + '</span>';
                        outputDiv.scrollTop = outputDiv.scrollHeight;
                    });
                    
                    progressFill.style.width = '100%';
                    progressFill.textContent = '100% - –û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!';
                    
                    outputDiv.innerHTML += '\n\n<span class="success">‚úì –û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!</span>';
                    outputDiv.innerHTML += '\n<span class="success">  –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞: ' + result.finalLoss.toFixed(6) + '</span>';
                    outputDiv.innerHTML += '\n<span class="success">  –í—Å–µ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ ' + (epochs * globalTrainingData.length).toLocaleString() + ' –∏—Ç–µ—Ä–∞—Ü–∏–π –æ–±—É—á–µ–Ω–∏—è!</span>';
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                    statsDiv.style.display = 'grid';
                    statsDiv.innerHTML = `
                        <div class="stat-card">
                            <div class="stat-value">${epochs}</div>
                            <div class="stat-label">–≠–ø–æ—Ö –æ–±—É—á–µ–Ω–∏—è</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${globalTrainingData.length}</div>
                            <div class="stat-label">–ü—Ä–∏–º–µ—Ä–æ–≤ –∫–æ–¥–∞</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${result.finalLoss.toFixed(4)}</div>
                            <div class="stat-label">–§–∏–Ω–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${((1 - Math.min(result.finalLoss / 100, 1)) * 100).toFixed(1)}%</div>
                            <div class="stat-label">–¢–æ—á–Ω–æ—Å—Ç—å –º–æ–¥–µ–ª–∏</div>
                        </div>
                    `;
                    
                    // –°–∫—Ä—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
                    setTimeout(function() {
                        progressBar.style.display = 'none';
                    }, 3000);
                    
                } catch (error) {
                    outputDiv.innerHTML += '\n\n<span class="error">‚úó –û—à–∏–±–∫–∞ –æ–±—É—á–µ–Ω–∏—è: ' + error.message + '</span>';
                    progressFill.style.width = '100%';
                    progressFill.textContent = '–û—à–∏–±–∫–∞!';
                    progressBar.style.background = '#fee';
                    console.error(error);
                }
            }, 100);
        }
        
        function analyzeCode() {
            if (!globalNetwork) {
                alert('–°–Ω–∞—á–∞–ª–∞ –æ–±—É—á–∏—Ç–µ –Ω–µ–π—Ä–æ—Å–µ—Ç—å!');
                return;
            }
            
            var code = document.getElementById('user-code').value;
            var outputDiv = document.getElementById('analysis-output');
            outputDiv.style.display = 'block';
            
            try {
                outputDiv.innerHTML = '<span class="info">‚è≥ –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–¥...</span>';
                
                // –ü–∞—Ä—Å–∏–º –∫–æ–¥
                var lexer = new Lexer(code);
                var parser = new Parser(lexer);
                var ast = parser.parse();
                
                // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
                var extractor = new CodeFeatureExtractor();
                var features = extractor.extract(ast);
                
                outputDiv.innerHTML += '\n<span class="success">‚úì –ö–æ–¥ —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω</span>';
                outputDiv.innerHTML += '\n<span class="success">‚úì –ò–∑–≤–ª–µ—á–µ–Ω–æ ' + features.length + ' —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫</span>';
                
                // –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
                var predicted = globalNetwork.predict(features);
                
                outputDiv.innerHTML += '\n\n<span class="info">üìä –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∫–æ–¥–∞:</span>';
                outputDiv.innerHTML += '\n  ‚Ä¢ –í—Å–µ–≥–æ —É–∑–ª–æ–≤ AST: ' + extractor.nodeCounts.total;
                outputDiv.innerHTML += '\n  ‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞: ' + extractor.depthStats.max;
                outputDiv.innerHTML += '\n  ‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ü–∏–∫–ª–æ–≤: ' + extractor.nodeCounts.loops;
                outputDiv.innerHTML += '\n  ‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Å–ª–æ–≤–∏–π: ' + extractor.nodeCounts.ifs;
                outputDiv.innerHTML += '\n  ‚Ä¢ –ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π: ' + extractor.operationCounts.arithmetic;
                outputDiv.innerHTML += '\n  ‚Ä¢ –¶–∏–∫–ª–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: ' + extractor.features.cyclomaticComplexity;
                
                outputDiv.innerHTML += '\n\n<span class="success">üéØ –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏:</span>';
                outputDiv.innerHTML += '\n  ‚Ä¢ –û–∂–∏–¥–∞–µ–º–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: ' + predicted.toFixed(2) + ' –µ–¥–∏–Ω–∏—Ü';
                
                var category = '';
                if (predicted < 20) {
                    category = '–ë—ã—Å—Ç—Ä—ã–π –∫–æ–¥ ‚ö°';
                } else if (predicted < 50) {
                    category = '–°—Ä–µ–¥–Ω—è—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å üëç';
                } else if (predicted < 100) {
                    category = '–ú–µ–¥–ª–µ–Ω–Ω—ã–π –∫–æ–¥ ‚ö†Ô∏è';
                } else {
                    category = '–û—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω—ã–π –∫–æ–¥ üêå';
                }
                
                outputDiv.innerHTML += '\n  ‚Ä¢ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: ' + category;
                
                // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
                outputDiv.innerHTML += '\n\n<span class="info">üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:</span>';
                
                if (extractor.loopStats.nested > 0) {
                    outputDiv.innerHTML += '\n  ‚Ä¢ –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Ü–∏–∫–ª—ã - —Ä–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏';
                }
                
                if (extractor.nodeCounts.calls > 10) {
                    outputDiv.innerHTML += '\n  ‚Ä¢ –ú–Ω–æ–≥–æ –≤—ã–∑–æ–≤–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π - –º–æ–∂–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∏–Ω–ª–∞–π–Ω–∏–Ω–≥';
                }
                
                if (extractor.features.cyclomaticComplexity > 10) {
                    outputDiv.innerHTML += '\n  ‚Ä¢ –í—ã—Å–æ–∫–∞—è —Ü–∏–∫–ª–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å - —É–ø—Ä–æ—Å—Ç–∏—Ç–µ –ª–æ–≥–∏–∫—É';
                }
                
                if (extractor.operationCounts.arithmetic > 20) {
                    outputDiv.innerHTML += '\n  ‚Ä¢ –ú–Ω–æ–≥–æ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π - –º–æ–∂–Ω–æ –≤–µ–∫—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å';
                }
                
            } catch (error) {
                outputDiv.innerHTML = '<span class="error">‚úó –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: ' + error.message + '</span>';
                console.error(error);
            }
        }
        
        function generateRandomCode() {
            var code = generateRandomFunction();
            document.getElementById('user-code').value = code;
        }
        
        function comparePerformance() {
            if (!globalNetwork) {
                alert('–°–Ω–∞—á–∞–ª–∞ –æ–±—É—á–∏—Ç–µ –Ω–µ–π—Ä–æ—Å–µ—Ç—å!');
                return;
            }
            
            var outputDiv = document.getElementById('comparison-output');
            outputDiv.style.display = 'block';
            
            outputDiv.innerHTML = '<span class="info">‚è≥ –¢–µ—Å—Ç–∏—Ä—É–µ–º —Ç–æ—á–Ω–æ—Å—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π...</span>\n\n';
            
            setTimeout(function() {
                try {
                    var testSamples = generateTrainingData(10);
                    
                    outputDiv.innerHTML += '<span class="success">‚úì –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ ' + testSamples.length + ' —Ç–µ—Å—Ç–æ–≤—ã—Ö –ø—Ä–∏–º–µ—Ä–æ–≤</span>\n\n';
                    
                    var totalError = 0;
                    
                    for (var i = 0; i < testSamples.length; i++) {
                        var sample = testSamples[i];
                        var predicted = globalNetwork.predict(sample.input);
                        var actual = sample.target;
                        var error = Math.abs(predicted - actual);
                        var errorPercent = (error / actual * 100).toFixed(1);
                        
                        totalError += error;
                        
                        outputDiv.innerHTML += '<span class="info">–ü—Ä–∏–º–µ—Ä ' + (i + 1) + ':</span>\n';
                        outputDiv.innerHTML += '  –†–µ–∞–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: ' + actual.toFixed(2) + '\n';
                        outputDiv.innerHTML += '  –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–∞—è: ' + predicted.toFixed(2) + '\n';
                        outputDiv.innerHTML += '  –û—à–∏–±–∫–∞: ' + error.toFixed(2) + ' (' + errorPercent + '%)\n\n';
                    }
                    
                    var avgError = totalError / testSamples.length;
                    var accuracy = Math.max(0, 100 - avgError);
                    
                    outputDiv.innerHTML += '\n<span class="success">üìä –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</span>\n';
                    outputDiv.innerHTML += '  ‚Ä¢ –°—Ä–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞: ' + avgError.toFixed(2) + '\n';
                    outputDiv.innerHTML += '  ‚Ä¢ –¢–æ—á–Ω–æ—Å—Ç—å: ~' + accuracy.toFixed(1) + '%\n';
                    
                } catch (error) {
                    outputDiv.innerHTML = '<span class="error">‚úó –û—à–∏–±–∫–∞: ' + error.message + '</span>';
                    console.error(error);
                }
            }, 100);
        }
    </script>
</body>
</html>
